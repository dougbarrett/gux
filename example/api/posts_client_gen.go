// Code generated by apigen. DO NOT EDIT.
//go:build js && wasm

package api

import (
	"encoding/json"
	"fmt"

	"goquery/fetch"
)

// ClientOption configures a client
type ClientOption func(*clientConfig)

type clientConfig struct {
	baseURL  string
	basePath string
	headers  map[string]string
}

// WithBaseURL sets the base URL for API calls (e.g., "https://api.example.com")
func WithBaseURL(url string) ClientOption {
	return func(c *clientConfig) {
		c.baseURL = url
	}
}

// WithBasePath overrides the default API path prefix (e.g., "/api/v1/posts")
func WithBasePath(path string) ClientOption {
	return func(c *clientConfig) {
		c.basePath = path
	}
}

// WithHeader adds a header to all requests
func WithHeader(key, value string) ClientOption {
	return func(c *clientConfig) {
		if c.headers == nil {
			c.headers = make(map[string]string)
		}
		c.headers[key] = value
	}
}

func doRequest[T any](cfg *clientConfig, method, path string, body any) (T, error) {
	var result T

	url := cfg.baseURL + cfg.basePath + path

	var bodyStr string
	if body != nil {
		data, err := json.Marshal(body)
		if err != nil {
			return result, fmt.Errorf("marshal request: %w", err)
		}
		bodyStr = string(data)
	}

	headers := make(map[string]string)
	for k, v := range cfg.headers {
		headers[k] = v
	}
	if body != nil {
		headers["Content-Type"] = "application/json"
	}

	resp, err := fetch.Fetch(url, &fetch.Options{
		Method:  method,
		Headers: headers,
		Body:    bodyStr,
	})
	if err != nil {
		return result, fmt.Errorf("fetch failed: %w", err)
	}

	if !resp.OK {
		return result, fmt.Errorf("unexpected status %d: %s", resp.Status, resp.StatusText)
	}

	// For DELETE or no-content responses
	if resp.Body == "" {
		return result, nil
	}

	if err := json.Unmarshal([]byte(resp.Body), &result); err != nil {
		return result, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func doRequestNoResponse(cfg *clientConfig, method, path string) error {
	url := cfg.baseURL + cfg.basePath + path

	headers := make(map[string]string)
	for k, v := range cfg.headers {
		headers[k] = v
	}

	resp, err := fetch.Fetch(url, &fetch.Options{
		Method:  method,
		Headers: headers,
	})
	if err != nil {
		return fmt.Errorf("fetch failed: %w", err)
	}

	if !resp.OK {
		return fmt.Errorf("unexpected status %d: %s", resp.Status, resp.StatusText)
	}

	return nil
}


// PostsClient is a client for PostsAPI
type PostsClient struct {
	cfg *clientConfig
}

// NewPostsClient creates a new PostsClient
func NewPostsClient(opts ...ClientOption) *PostsClient {
	cfg := &clientConfig{
		baseURL:  "",
		basePath: "/api/posts",
	}
	for _, opt := range opts {
		opt(cfg)
	}
	return &PostsClient{cfg: cfg}
}


// GetAll fetches data via GET /api/posts/
func (c *PostsClient) GetAll() ([]Post, error) {
	return doRequest[[]Post](c.cfg, "GET", "/", nil)
}

// GetByID fetches data via GET /api/posts/{id}
func (c *PostsClient) GetByID(id int, ) (*Post, error) {
	result, err := doRequest[Post](c.cfg, "GET", fmt.Sprintf("/%d", id), nil)
	if err != nil {
		return nil, err
	}
	return &result, nil
}

// Create creates data via POST /api/posts/
func (c *PostsClient) Create(req CreatePostRequest) (*Post, error) {
	result, err := doRequest[Post](c.cfg, "POST", "/", req)
	if err != nil {
		return nil, err
	}
	return &result, nil
}

// Update updates data via PUT /api/posts/{id}
func (c *PostsClient) Update(id int, req CreatePostRequest) (*Post, error) {
	result, err := doRequest[Post](c.cfg, "PUT", fmt.Sprintf("/%d", id), req)
	if err != nil {
		return nil, err
	}
	return &result, nil
}

// Delete deletes data via DELETE /api/posts/{id}
func (c *PostsClient) Delete(id int) error {
	return doRequestNoResponse(c.cfg, "DELETE", fmt.Sprintf("/%d", id))
}


