// Code generated by gux. DO NOT EDIT.
//go:build js && wasm

package api

import (
	"encoding/json"
	"fmt"

	"github.com/dougbarrett/gux/fetch"
)

// ClientOption configures a client
type ClientOption func(*clientConfig)

type clientConfig struct {
	baseURL      string
	basePath     string
	headers      map[string]string
	authProvider func() string
}

// WithBaseURL sets the base URL for API calls (e.g., "https://api.example.com")
func WithBaseURL(url string) ClientOption {
	return func(c *clientConfig) {
		c.baseURL = url
	}
}

// WithBasePath overrides the default API path prefix (e.g., "/api/v1/posts")
func WithBasePath(path string) ClientOption {
	return func(c *clientConfig) {
		c.basePath = path
	}
}

// WithHeader adds a header to all requests
func WithHeader(key, value string) ClientOption {
	return func(c *clientConfig) {
		if c.headers == nil {
			c.headers = make(map[string]string)
		}
		c.headers[key] = value
	}
}

// WithAuthProvider sets a function that provides the Authorization header value dynamically.
// The function is called on each request, allowing for token refresh scenarios.
// Example: WithAuthProvider(func() string { return "Bearer " + auth.GetToken() })
func WithAuthProvider(provider func() string) ClientOption {
	return func(c *clientConfig) {
		c.authProvider = provider
	}
}

func doRequest[T any](cfg *clientConfig, method, path string, body any) (T, error) {
	var result T

	url := cfg.baseURL + cfg.basePath + path

	var bodyStr string
	if body != nil {
		data, err := json.Marshal(body)
		if err != nil {
			return result, fmt.Errorf("marshal request: %w", err)
		}
		bodyStr = string(data)
	}

	headers := make(map[string]string)
	for k, v := range cfg.headers {
		headers[k] = v
	}
	if cfg.authProvider != nil {
		if authValue := cfg.authProvider(); authValue != "" {
			headers["Authorization"] = authValue
		}
	}
	if body != nil {
		headers["Content-Type"] = "application/json"
	}

	resp, err := fetch.Fetch(url, &fetch.Options{
		Method:  method,
		Headers: headers,
		Body:    bodyStr,
	})
	if err != nil {
		return result, fmt.Errorf("fetch failed: %w", err)
	}

	if !resp.OK {
		return result, fmt.Errorf("unexpected status %d: %s", resp.Status, resp.StatusText)
	}

	// For DELETE or no-content responses
	if resp.Body == "" {
		return result, nil
	}

	if err := json.Unmarshal([]byte(resp.Body), &result); err != nil {
		return result, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func doRequestNoResponse(cfg *clientConfig, method, path string) error {
	url := cfg.baseURL + cfg.basePath + path

	headers := make(map[string]string)
	for k, v := range cfg.headers {
		headers[k] = v
	}
	if cfg.authProvider != nil {
		if authValue := cfg.authProvider(); authValue != "" {
			headers["Authorization"] = authValue
		}
	}

	resp, err := fetch.Fetch(url, &fetch.Options{
		Method:  method,
		Headers: headers,
	})
	if err != nil {
		return fmt.Errorf("fetch failed: %w", err)
	}

	if !resp.OK {
		return fmt.Errorf("unexpected status %d: %s", resp.Status, resp.StatusText)
	}

	return nil
}
