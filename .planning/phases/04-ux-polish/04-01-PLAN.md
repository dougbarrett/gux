---
phase: 04-ux-polish
plan: 01
type: execute
---

<objective>
Add localStorage persistence for sidebar collapse state.

Purpose: Users expect the sidebar to remember its collapsed/expanded state across page reloads.
Output: Sidebar state persists to localStorage and restores on page load.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-layout-navigation/02-01-SUMMARY.md

# Key files:
@components/sidebar.go
@components/theme.go  # Reference for localStorage pattern
@state/storage.go  # Reference for persistence utilities

**Tech available:** localStorage via state.LocalStorage() or direct js.Global().Get("localStorage")
**Established pattern:** theme.go uses direct localStorage (lines 161-173, 213-216) - follow same pattern for consistency

**Constraining decisions:**
- Phase 02-01: Sidebar has Collapse()/Expand()/ToggleCollapse() methods
- Phase 02-01: Keyboard shortcut (Cmd/Ctrl+B) registered separately via RegisterKeyboardShortcut()
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add localStorage persistence to Sidebar</name>
  <files>components/sidebar.go</files>
  <action>
Add sidebar collapse state persistence following the theme.go pattern:

1. Add a storage key constant: `const sidebarStorageKey = "gux-sidebar-collapsed"`

2. In NewSidebar(), after creating the sidebar struct, load saved state from localStorage:
   - Check localStorage for saved preference
   - If found and "true", call s.Collapse() (but don't call onCollapse callback during init)
   - Add a flag `initializing` to prevent callback during load, or just set isCollapsed directly

3. In Collapse() and Expand() methods, save state to localStorage after updating:
   - Use `js.Global().Get("localStorage").Call("setItem", sidebarStorageKey, "true/false")`
   - Follow the exact pattern from theme.go lines 213-216

4. Add SetCollapsed(collapsed bool) method for programmatic control that also persists.

Do NOT use state.NewPersistentStore - keep it simple like theme.go does with direct localStorage access.
  </action>
  <verify>
1. Build succeeds: `cd example && make build`
2. Run app: `cd example && make run`
3. Collapse sidebar (click button or Cmd+B)
4. Reload page - sidebar should remain collapsed
5. Expand sidebar, reload - should remain expanded
  </verify>
  <done>
- Sidebar collapse state persists across page reloads
- Both button click and keyboard shortcut trigger persistence
- No errors in console
  </done>
</task>

<task type="auto">
  <name>Task 2: Add clear preference method</name>
  <files>components/sidebar.go</files>
  <action>
Add a method to clear the saved preference (for settings/reset functionality):

1. Add ClearSavedState() method that removes the localStorage key
2. This allows users to reset to default expanded state if needed

Simple implementation:
```go
func (s *Sidebar) ClearSavedState() {
    localStorage := js.Global().Get("localStorage")
    if !localStorage.IsUndefined() && !localStorage.IsNull() {
        localStorage.Call("removeItem", sidebarStorageKey)
    }
}
```
  </action>
  <verify>
1. Build succeeds: `cd example && make build`
2. Verify method exists and is callable
  </verify>
  <done>
- ClearSavedState() method exists
- Method removes localStorage key when called
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd example && make build` succeeds
- [ ] Sidebar state persists across page reloads
- [ ] Keyboard shortcut (Cmd/Ctrl+B) still works
- [ ] ClearSavedState() method exists
</verification>

<success_criteria>
- All tasks completed
- Sidebar collapse state persists to localStorage
- State restores correctly on page load
- No TypeScript/Go errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-ux-polish/04-01-SUMMARY.md`
</output>
